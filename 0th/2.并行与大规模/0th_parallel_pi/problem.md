{
  "result": "# MPI 算个 PI\n\n## 前情提要\n\n本题是简单题，不想读背景的大佬请直接跳到`题目要求`。\n\n## 背景\n\n几乎从人类数学诞生以来，一代代数学家就在试图提高圆周率$\\pi$的数值精度。从五千年前的1位精度提升到当下世界纪录的100万亿位，$\\pi$的计算方法从粗略估计、测量估算，再到公式逼近、机器演算，我们可以从中看到人类科技的发展史。\n\n![Record_pi_approximations](https://hpcgame.pku.edu.cn/oss/images/mpi/Record_pi_approximations.svg)\n\n当下，$\\pi$的计算还是衡量高性能计算集群性能和算法优越性的重要量度，问题的维度从单纯的计算，拓展到了储存、通信、内存瓶颈等方方面面，各路超算纷纷借此机会大秀肌肉。\n\n但是在这一系列浩浩汤汤的计算过程中，有一小群人，在个人电脑刚刚普及的年代，却凭借着合作的力量，通过众包计算的方法，也达到了可喜的成就。其中一个项目是，通过分布式的方法，计算出了$\\pi$中特殊位置数字的[PiHex](http://wayback.cecm.sfu.ca/projects/pihex/index.html)。在个人算力不足的年代，这可谓是工程学奇迹。\n\n现在我们假设你有一些算力不是很强的机器，来模拟这个场景。\n\n## 题目要求\n\n你有5个物理节点，每个的节点2个核心。你需要写一个`MPI`程序，计算$\\pi$的近似值，精确到$1* 10^{-14}$（15位有效数字）。\n\n因为MPI开销比较大，本题时间限制为30秒，不考察效率。（其实就是想让大家试一试`MPI`)\n\n请注意，我们的平台关闭了超线程，但是直接由`MPI`生成的线程数可能会是打开超线程后的。\n\n## 输入输出\n\n输入：无\n\n输出：一个双精度浮点数，保留15位有效数字。输出到`output.txt`即可。如果只有13位有效数字，则得一半分。\n\n## 编译命令\n\n（运行mpi.tar中的compile.sh即可）\n\n```shell\nmodule load mpi/2021.8.0\nmpicc cpi.c -lm -o cpi\n```\n\n## 运行命令\n\n（运行mpi.tar中的run.sh即可）\n\n```shell\nsalloc -p compute -N5 --ntasks-per-node=2 -c 1 -q normal\nmodule load mpi/2021.8.0\nsrun -c 1 hostname -s | sort -n > slurm.hosts\nmpirun -np 10 -machinefile slurm.hosts ./cpi\n```\n\n## 评分细节\n\n请不要使用直接打表的方法，否则本题零分。我们会进行人工核验。毕竟这样一个程序并不难写，何乐而不为呢。\n\n## 参考计算方法\n（也可以用其他方法，下面这个方法精度不算很高）\n\n（引自北京大学，杨超，并行与分布式计算基础)\n\n![计算方法](https://hpcgame.pku.edu.cn/oss/images/mpi/ppt.png)\n\n## 参考资料\n\nMPI讲座：https://www.bilibili.com/video/BV13v4y1v7y7"
}